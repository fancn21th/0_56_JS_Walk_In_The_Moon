# Master Javascripts

## Part 0

1. History:
    Netscape and Sun
    Netscape and Microsoft
    Microsoft XHR
    ECMAScript
    Ajax in 2005
    Popular in 2007

    Javascript is the only programming language that people don't bother to learn before using
      Name
      Mispositioning
      Design Errors
      Bad Impementations
      The Browser
      Bad Books
      Substandard Standard

    There is no standard that says that a web browser must implement Javascript

2. Key ideas
    Load and go delivery
    Loose typing
    Objects as general containers // great
    Prototypal inheritance        // great
    Lambda                        // great
    Linkage though global variables

## Part I & II

3. Values
    Numbers
    Strings
    Booleans
    Objects
    null
    undefined

4. Only one nubmer type
    64 bit floating point
    Double
    0.1 + 0.2 !== 0.3

5. NaN
    Result of undefined or erroneous operations
    Any arithmetic operation with NaN as an input will have NaN as a result
    NaN is not equal to anything including NaN (NaN === NaN is false)

6. parseInt function
    Converts the value into number
    It stops at the first non-digit character
        parseInt('12em') === 12
    The radix(10) should always be used
        parseInt('08') === 0
        parseInt('08', 10) === 8

7. Strings
    Sequence of 0 or more 16-bit characters
    No separate character type
        Characters are represented as strings with length of 1
    Strings are immutable

8. string.length
    extented characters counted as 2

9. undefined
    default value for variables and parameters

    The value of missing members in objects

10. Falsy values
    null, 0, '', undefined, false, NaN

    '0', 'false' are truthy

11. Dynamic Objects
    Unification of Object and Hashtable
    new Object() produces an empty container of name/value pairs
    A name can be any string, a value can be any value except undefined
    members can be accessed with dot notation or subscript notation
    No hash nature is visible (no hash codes or rehash methods)

12. Loosely Typed

13. Identifiers
    Starts with a letter or _ or $
    Followed by zero or more letters, digits, _ or $
    By convention, all variables, parameters, members, and function names start with lower case
    Except for constructor fucntions which starts with upper case
    Initial _ should be reservered for implementations
    $ should be reserved for machines

14. Addition and concatenation
    If both operands are numbers
        then
            add them
        else
            convert them both to strings
            concatenate them

15. Unary operator can convert strings to numbers
    + '42' = 42
    Number('42') = 42
    parseInt('42', 10) = 42
    + '3' + (+ '4') = 7

16. Division of two integers can produce a non-integer result
    10 / 3 = 3.33333333....335

17. == & !=
    Equal and not equal
    These operators can do type coercion
    It is always better to user === and ==, which do not do type coercion

18. Evils of type coercion
    '' == '0' // false
    0 == ''   // true
    0 == '0'  // true

    false == 'false' // false
    false == '0'     // true

    false == undefined // false
    false == null      // false
    null  == undefined // true

    '\t\r\n' == 0      // true

19. &&
    The guard operator, aka logical and
    If first operand is truthy
        then result is second operand
        else result is first operand
    It can be used to avoid null references
        if (a) {
            return a.member;
        } else {
            return a;
        }
    can be written as
        return a && a.member;

20. ||
    The default operator, aka logical or
    If first operand is truthy
        then result is first operand
        else result is second operand
    It can be used to fill in default values
        var last = input || nr_items;
    (If input is truthy, then last is input, otherwise set last to nr_items.)

21. !! produce booleans

22. Bitwise
    & | ^ >> >>> <<
    The bitwise operators convert the operand to a 32-bit signed integer, and turn the result back into 64-bit floating point.

23. Break statement
    loop: for(;;) {
        ...
        if(...) {
            break loop;
        }
        ...
    }

24. For in statement
    for(var name in object){
        if(object.hasOwnProperty(name)){
            // within the loop.
            // name is the key of current memeber
            // object[name] is the current value
        }
    }

25. Switch statement
    Multiway branch
    The switch value doese not neeed to a number. It can be a string
    The case values can be expressions
    Danger: Cases fall through to the next case unless a disruptive statement like break ends the case

26. Throw statement
    throw new Error(reason)
    throw {
        name: exceptionName,
        message: reason
    };

27. Try statement
    try {
        ...
    } catch (e) {
        switch (e.name) {
            case 'Error':
                ...
                break;
            default:
                throw e;
        }
    }

    one catch block since no expection type

    exception names

        'Error'
        'EvalError'
        'RangeError'
        'SyntaxError'
        'TypeError'
        'URIError'

28. With statement
    do not use it

29. Function statement
    function name(parameters) {
        statements;
    }

30. Scope
    Only functions have scope
    Vars defined in a function are not visible outside of the function
    Defined all vars at the beginning of a function

31. Return
    return expression;

    or

    return;

    If there is no expression, then the return value is undefined

    Except for consturctors, whose default return value is this

32. Objects
    Everything else is objects

    Objects can contain data and methods

    Objects can inherit from other objects

33. Collections
    An object is an unordered collection of name/value pairs

    Names are strings

    Values are any type, including other objects

    Good for representing records and trees

    Every object is a little database

34. Object Literals
    Object literals are wrapped in {}

    Names can be names and strings

    Values can be expressions
    : separates names and values
    , separates pairs

    Object literals can be used anywhere a value can appear


    bad way

    function SuperDiv(width, height, left, top, zIndex, position, color, visibility, html, cssClass)

    good way

    function SuperDiv(spec)

35. Linkage
    Objects can be created with a secret link to another object (revealed by Mozilla by __proto__)

    If an attempt to access a name fails, the secret linked object will be used

    The secret link is not used when storing. New members are only added to the primary object

    The Object.create(o) method makes a new empty object with a lnk to object o

36. Inheritance
    Linkage provides simple inheritance

    An object can inherit from an older object

37. Object Methods
    All objects are linked directly or indirectly to Object.prototype

    All objects inherit some basic methods

    None of them are very userful

    hasOwnProperty is useful

    No copy method

    No equals method

38. Object Constuction
    Make a new empty object

    All three of these expressions have exactly the same result:
        new Object()
        {}
        Object.create(Object.prototype)

    {} is the prefered form

39. Reference
    Objects can be passed as arguments to functions, and can be returned by functions
        Objects are passed by reference
        Objects are not passed by value
    The === operator compares object references, not values
        true only if both operands are the same object

40. Arrays
    Array inherits from object

    Indexes are converted to strings and used as names for retrieving values

    very efficient or sparse arrays

    No very efficient in most other cases

    One advantage: No need to provide a length or type when creating an array

    Array, unlike objects, have a special length member

    It is always 1 larger than the highest integer subscript

    It allow use of the traditional for statement

    Do not use for..in with arrays

41. Array Literals
    An array literal use []

    It can contain any number of expressions, separated by commas
        myList = ['oats', 'peas', 'beans']

    New items can be appended
        myList[myList.length] = 'barley'

    The dot notation should not be used with arrays

    [] is preferred to new Array()

42. Deleting Elements
    myArray = ['a', 'b', 'c', 'd']
    delete myArray[1]
    // ['a', undefined, 'c', 'd']
    myArray.splice(1, 1)
    // ['a', 'b', 'd']

43. Arrays v Objects
    Use objects when the names are arbitrary strings

    Use arrays when the names are sequential integers

    Don't get confused by the term associative array

44. Functions
    Functions are first-class objects

    1. Functions can be passed, returned and stored just like any other value

    2. Functoins inherit from Object and can store name/value pairs

45. Function operator
    A function can appear anywhere that an expression can appear

46. lambda

47. Function statement
    function foo() {}

        expands to

    var foo = function foo() {}

48. Scope
    An inner function has access to the variables and parameters of functions that it is contained within

    This is known as Static Scoping or Lexical Scoping

49. Closure
    The scope that an inner function enjoys continues even after the parent functions have retured

    This is called closure

    Example

        function fade(id) {
            var dom = document.getElementById(id)
            var level = 1
            function step(){
                var h =  level.toString(16)
                dom.style.backgroundColor = '#FFFF' + h + h
                if(leven < 16) {
                    level += 1
                    setTimeout(step, 100)
                }
            }
            setTimeout(step, 100)
        }

50. Function Objects
    Functoins are objects, so they can contain name/value pairs

    This can serve the same purpose as static memebers in other languages

51. Method
    Since functions are values, functions can be stored in objects

    A function in an object is called a method

52. Invocation

    Fucnton Form
        functionObject(arguments)

    Method form
        thisObject.methodName(arguments)
        thisObject['methodName'](arguments)

    Constructor form
        new FunctionObject(arguments)

    Apply form
        functionObject.apply(thisObject, [arguments])

53. Method form (context aka this)
    thisObject.methodName(arguments)

    When a function is called in the method form, this is set to thisObject, the object containing the function

    This allows methods to have a reference to the object of interest

54. Function form
    this is set to the global object

    it makes it harder to write helper functions within a method because the helper function does not get access to the outer this.
        var that = this

55. Constructor form
    When a function is called with the new operator, a new object is created and assigned to this
    if there is not an explict return value, then this will be returned
    Used in the Pseudoclassical style

56. arguments

57. typeof
    type          |        typeof
    ---------------------------------------------
    object        |        'object'
    function      |        'function'
    array         |        'object'         *****
    number        |        'number'
    string        |        'string'
    boolean       |        'boolean'
    null          |        'object'         *****
    undefined     |        'undefined'

58. Augmenting Built-in Types

    trim

    if (typeof String.prototype.trim !== 'function') {
        String.prototype.trim = function() {
            return this.replace(
                /^\s*(\S*(\s+\S+)*)\s*$/,
                '$1'
            )
        }
    }

    supplant

    if (typeof String.prototype.supplant !== 'function') {
      String.prototype.supplant = function (o) {
        return this.replace(
          /{([^{}]*)}/g,
          function (a, b) {
            var r = o[b];
            return typeof r === 'string' || typeof r === 'number' ? r : a;
          }
        );
      };
    }

59. Arrays and Inheritance
    Don't use arrays as prototypes
        The object produced this way does not have array nature. It will inherite the array's values and methods, but not it's length

    You can augument an individual array
        Assign a method to it
        This works because arrays are objects

    You can augument all arrays
        Assign methods to Array.prototype

60. Distinguishing Arrays
    value.consturctor === Array
    value instanceof Array
    Neither of thos work when the value comes from a diffrent frame
    In the future

61. eval
    eval(string)
    The eval function compiles and executes a string and returns the result
    It is what the browser uses to convert strings into actions
    It is the most misused feature of the language
    Do not use it unless you really know what you are doing

62. Function function
    new Function(parameters, body)
    The Function consturctor takes zero or more parameter name strings, and a body string, and uses the Javascript compiler to produce a function object
    It should only be used to complie fresh source from a server
    It is closedly related to eval

63. Built-in Type Wrappers
    Java has int and Integer, two incompatible types which can both carry the same values with differing levels of efficiency and convenience

    Javascript copied this pattern to no advantage. Avoid it.

    Avoid new Boolean()
    Avoid new String()
    Avoid new Number()

64. Agumentation
    We can directly modify individual objects to give them just the characteristics we want
    We can do this without having to create classes
    We can then use our new object as the prototype for lots of new objects, each of which can also be augmented

65. Working with the Grain
    Classical patterns are less effective than prototypal patterns or parasitic patterns
    Formal classes are not needed for reuse or extension

65. (global) Object
    The object that dares not speak its name
    It is the container for all global variables and all built-in objects
    Sometimes this points to it
        var global = this;
    On browsers, window is the global object

66. Global variables are evil
    Functions within an application can clobber each other
    Cooperating applications can clobber each other
    Use of the golbal namespace must be minimized

67. Implied Global
    Any variable which is not properly declared is assumed to be global by default
    This makes it easy for people who do not know or care about encapsulation to be productive, but it makes applcation less reliable
    This statement may use a global variable i
        for(i = 0; i < n; i++)

68. Namespace
    Every object is a separate namespace
    Use an object to organize your variables and functions
    The MYAPP object
        <head>
        <script>
            MYAPP = {}
        </script>

69. Encapsulate
    Function scope can create an encapsulation

    Use an anonymous function to wrap your application

    i.e.

    MYAPP.Trivia = (function(){
        // define your common vars here
        // define your common functions here
        return {
            getNextPoster: function(cata, diff) {
                ...
            },
            showPoser: function(){
                ...
            }
        }
    })()

70. Thinking about type
    Trading type-safety for dynamisom
    Javascript has no cast operator
    Reflection is really easy, and usually unnecessary
    Why inheritance ?
        Automactic casting
        Code resue
    Trading brittleness for flexibility

71. Date
    The Date function is basedon Java's Date class
    It was not Y2K ready *

72. RegExp
    Regular expression pattern matcher
    Patterns are enclosed in slashes
    Example: a pattern that matches regular expressions
        ...
    Bizarre notation, difficult to read

    Popular

73. Threads
    The language definition is neutral on threads
    Some language processors (like SpiderMonkey) provide thread support
    Most application environments (like browsers) do not provide it
    Threads are evil

## Part III

74. Inheritance is object-oriented code resue
    Two Schools
        Classical
        Prototypal

75. Pseudoclassical Inheritance
    Three mechanisms
      Constructor Functions
        this returned by default
        by convention uppcase consturctor name
      The new operator
      The prototype memeber of functions

    var foo = function() {}
    foo.prototype.constructor === foo // truthy

    function ChildConstuctor() {}
    ChildConstuctor.prototype = new ParentConstuctor()

    __proto__ is the hidden link only supported by Mozilla

    Dynamic structure

76. Prototypal Inheritance
    function in javascript do all those things
      methods
      functions
      constructors
      modules
      classes

    Object.create()

    if (typeof Object.create !== 'function') {
      Object.create = function(o) {
        function F() {}
        F.prototype = o
        return new F()
      }
    }

    Objects inherit from Objects
    A Object contains a secret link to another Objects
    Mozilla call it __proto__

    var b = {}
    b.__proto__.constructor === Object // truthy

77. Function Inheritance
    Singletons
      var singleton = {
        foo: function() {}
      }

    Closure
      a function object contains
        a function (name, parameters, body)
        a reference to the environment in which it was created (context)

    var singleton = (function() {
      var privateVariable;
      function privateFunction() {
        ...privateVariable
      }
      return {
        firstMethod: function(){
          ...privateVariable
        },
        secondeMethod: function(){
          ...privateVariable
        }
      }
    })();

    Power Constructor - Pattern
      1 Make an object
         Object Literal
         new
         Object.create()
         call another power constructor

      2 Define some variables and Functions
        these become private members

      3 Agument the object with privileged methods

      4 Return Object

      function myPowerConstructor(x) {
        var that = otherMakter(x)
        var secret = f(x)
        that.priv = function() {
          ... secret x that ...
        }
        return that
      }

        function symbol(s, p) {
          return {
            id: s,
            lbp: p,
            value: s
          }
        }

        function delim(s) {
          return symbol(s, 0)
        }

        function stmt(s, f) {
          var x = delim(s)
          x.identifier = true
          x.reserved = true
          x.fud = f
          return x
        }

        function blockstmt(s, f) {
          var x = stmt(s, f)
          x.block = true
          return x
        }

      Super methods
        function hoozit(id) {
          var secret = {}
          var that = gizmo(id, secret)
          var super_toString = that.super_toString
          that.test = function(testid) {
            return testid === secret.id
          }
          that.toString = function() {
            return super_toString.apply(that) // super method
          }
          return that
        }

78. multiples as it is called
    var ids = [1,2,3,4]
    var divs = ids.map(function(id) {
      return '<div id="' + id + '" style="width: 100px: height: 100px; background: red; margin-top: 10px">' + id + '</div>'
    })
    document.body.innerHTML = divs.join('')
    var divElements = document.getElementsByTagName('div')

    // it works not as expected
    for(var i = 0; i < divElements.length; i++) {
      divElements[i].onmouseover = function() {
        console.log(i)
      }
    }

    // it works!
    for(var i = 0; i < divElements.length; i++) {
      divElements[i].onmouseover = function(i) {
        return function() {
          console.log(i)
        }
      }(i)
    }

79. arguments is not a plain array
    function foo(a) {
      console.log(arguments)
      console.log(arguments.slice(2)) // it won't works
      console.log(Array.prototype.slice.apply(arguments, [2])) // it gets [3, 4]
    }

    foo(1,2,3,4)

## Part IV

80. loop
  flow   -->    paint
    ^             v
  script <--    event

81. <script></script>
  can be big impact on page loading Time
  * place <script/> tags as close to the bottom of the body as possible
  * place <link/> as high in the head as possible
  * minify and gzip script files
  * reduce the number of script files as much as possible

82. document.write is bad
  * allows javascripts to produce html context
  * before onload : inserts html text into document
  * after  onload : uses html text to replace the current document
  * no recommended

83. collections
  * document.anchors
  * document.applets
  * document.embeds
  * document.forms
  * document.frames
  * document.images
  * document.plugins
  * document.javascripts
  * document.stylesheets

84. name and id
  * name
    identifies values in form data
    identifies a window/frame
  * id
    uniquely identifies an element

85. retrieving nodes
  * document.getElementById(id)
  * document.getElementByName(name)
  * node.getElementsByTagName(tagName)

86. document tree structure
  * visual structure not equal to document structure

87. walk the DOM
  * using recursion
    function walkTheDOM(node, func) {
      func(node)
      node = node.firstChild
      while(node) {
        walkTheDOM(node, func)
        node = node.nextSibling
      }
    }

88. getElementByClassName
  function getElementByClassName(className) {
    var results = []
    walkTheDOM(document.body, function(node){
      var a, c = node.className, i
      if (c) {
        a = c.split(' ')
        for(i = 0; i< a.length; i++) {
          if(a[i] === className) {
            results.push(node)
            break
          }
        }
      }
    })
    return results
  }

89. childNodes

90. style
  node.className
  node.style.stylename
  node.currentStyle.stylename

  // W3C
  document.defaultView().getComputedStyle(node, "").getPropertyValue(stylename)

91. Style Names
  css                           javascript
  backgroud-color               backgroundColor
  border-radius                 borderRadius
  float                         cssFloat

92. Making Elements
  document.createElement(tagName)
  document.createTextNode(text)
  node.cloneNode()
    Clone an individual element
  node.cloneNode(true)
    Clone an element and all of its descendents

  * the new nodes are not connected to the document

93. Linking Elements
  node.appendChild(new)
  node.insertBefore(new, sibling)
  node.replaceChild(new, old)

  old.parentNode.replaceChild(new, old)

94. Removing Elements
  node.removeChild(old)
    it return the node
    be sure to remove any event handlers

  old.parentNode.removeChild(old)

95. innerHTML
  W3C against
  Microsoft and other browsers

  * should not put script tag inside

96. Which way is better ?
  Favor clean code and esay maintenance
  Favor performance only in extreme cases

97. Events
  * an event-driven, single-threaded, asynchronous programming model
  * events are targeted to particular nodes
  * events cause the invocation of event handler functions
  * The target is the topmost (z-index) node containing the cursor
    click
    dbclick
    mousedown
    mousemove
    mouseout
    mouseover
    mouseup

98. Event handlers
  * Classic
    node["on" + type] = f
  * Microsoft
    node.attachEvent("on" + type, f)
  * W3C
    node.addEventListener(type, f, false)
  * The handler takes an optional event parameter
    Microsoft does not send an event parameter, use the global event object instead

  fucntion (e) {
    e = e || event
    var target = e.target || e.srcElement
    ...
  }

99. Event Bubbling
  why ?
  * suppose you have 100 draggable Objects
  * you could attach 100 sets of event handlers to those Objects
  * or you could attach one set of event handlers to the container of the 100 objects

100. Cancel Bubbling
  * Cancel bubbling to keep the parent nodes from seeing the event
    e.cancelBubble = true
    if (e.stopPropagation) {
      e.stopPropagation()
    }

101. Prevent Default Action
  * An event handler can prevent a browser action associated with the event (such as submitting a form)
  associated with the event (such as submitting a form)
    e.returnValue = false
    if (e.preventDefault) {
      e.preventDefault()
    }
    return false

102. Memory Leaks
  IE 6 , IE 7
  * Explicitly remove all of your event handlers from nodes before you discard them

  * Remove all event handlers from deleted DOM nodes
  * It must be done on nodes before removeChild or repalceChild
  * It must be done on nodes before they are replaced by changing innerHTML

  function purgeEventHandlers(node) {
    walkTheDOM(node, function(e){
      for (var n in e) {
        if(typeof e[n] === 'function') {
          e[n] = null
        }
      }
    })
  }

103. Javascript of Browser
  alert
  confirm
  prompt
   these functions break the asynchronous model
   avoid these in Ajax applications

  setTimeout
  setInterval

104. window
  * The window object is also the JavaScript global object
  * Every window, frame and iframe has its own unique window object
  * aka self. And sometimes parent and top

105. inter-window
  * frames[]    child frames and iframes
  * name        text name of window
  * opener      reference to open
  * parent      reference to parent
  * self        reference to this window
  * top         reference to outermost
  * window      reference to this window

  * open()      open new window

106. inter-window
  * A script can access another window if
    It can get a reference to it
    document.domain === otherWindow.document.domain

107. Cross browser
  * Weak standard result in significant vendor-speicific differences between browsers

    * Browser Detection
      lie... (IE identified itself as Mozila 4)
    * Feature Detection
    * Platform Libraries
        Recommended

108. Feature Detection
  * Using reflection, ask if desired features are present
  * Execute conditionally
    function addEventHandler(node, type, f) {
      node['on' + type] = f
    }

109. The Cracks of DOM
  * The DOM buglist includes all of the bugs in the browser
  * The DOM buglist includes all of the bugs in all supported browsers
  * No DOM completely implements the standards
  * Much of the DOM is not described in any standard

110. Coping
  1. Do what works
  2. Do what is common
  3. Do what is standard

## Part V

111. The sessionless web
  * Cookies for psudosessions
  * Cookies enable CSRF attacks
  * Every action results in a page replacement
  * Pages are heavy, complicated, multipart things
  * The web is a big step backwards in individual productivity

112. The ajax revolution

113. Premature optimization is the root of all evil
  * Use YSlow to reduce startup time
  * Don't optimize until you need to, but find out as early as possible if you neeed to
  * Clean, correct code is easier to optimize
  * Tweaking is usually ineffective
  * Sometimes restructuring or redesign is required

114. A Example
  var count = 0
  var fibonacci = function(n) {
    count ++
    return n < 2 ? n : fibonacci(n-1) + fibonacci(n-2)
  }

  // fibonacci(40)
  // call itself 331,160,280 times

  var memoizer = function(memo, fundamental) {
    var shell = function(n) {
      var result = memo[n]
      if(typeof result !== 'number') {
        result = fundamental(shell, n)
        memo[n] = result
      }
      return result
    }
    return shell
  }

  var fibonacci = memoizer([0, 1], function( recur, n) {
      return recur(n-1) + recur(n-2)
  })

  // fibonacci(40)
  // calls itself 38 times
  * The key to optimization is work avoidance

115. Code Quality
  * High quality code is most likely to avoid platform problems
  * Code Convention for the JavaScript Programming Language
  * JSLint.com

116. Have regular code readings
  * Don't wait until release to do code reviews
  * Do team code reading regularly during development
  * Experienced developers can lead by example   *****
  * Novice developers learn from the group
  * Probelms can be discovered early
  * Good techniqures can be shraed early

117. Two kinds of optimization
  * Streamlining
    Algorithem replacement
    Work avoidance
    Code removal
    These things are always good to do

  * Special Casing
    Add cruft, increase code size
    Should only be done when proven necessary

118. Avoid uncessary displays or animation

119. Improving performance
  * If javascript were infinitely fast, most pages would run at about the same speed
  * The bottleneck tends to be the DOM interface
  * There is a significant cost every time you touch DOM tree
  * Each touch can result in a reflow computation, which is expensive

120. Touch lightly
  * It is faster to manipulate new nodes before they are attched to the tree
  * Touching unattached nodes avoids the reflow cost
  * Setting innerHTML does an enormous amount of work, but browsers are really good at it, and it only touches the DOM once.

121. Code Efficiency
  * Common subexpresion removal
  * Loop invariant removal
  * Most compilers in most programming languages do these optimizations for you
  * But not javascript

  example
    before
      var i
      for(i = 0; i < divs.length; i++){
        divs[i].style.color = "black"
        divs[i].style.border = thickness + 'px solid blue'
        divs[i].style.backgroundColor = 'white'
      }

    after
      var border =  thickness + 'px solid blue',
          nrDivs = divs.length,
          ds,
          i
      for(i = 0; i < nrDivs; i+=1 ) {
        ds = divs[i].style
        ds.color = 'black'
        ds.border = border
        ds.backgroundColor = 'white'
      }

122. Strings
  * Concatenantion with +
    Each operation allocates memory
    foo = a + b

  * Concatenantion with array.join('')
    The contents of an array are concatenated into a single string
    foo = [a, b].join('')

123. Don't tune for quirks
  * Some browsers have suprprising inefficiencies
  * A trick that is faster on Brower A might be slower on Browser B
  * The performance characterisitics of the next generation may be significantly different
  * Avoid short-term optimizations

124. Don't optimize without measuring
  * Intuitions are often wrong
     start_time = new Date.valueof()
     code_to_measured()
     end_time = new Date.valueOf()
     elapsed_time = end_time - start_time

  * A single trial is unreliable. Timers can be off by as much as 15 msec
  * Even accurate measurements can lead to wrong conclusions

125. O(1)
  An operation that is performed only once is not worth optimizing

126. O(n)
  An operation that is performed many times may be worth optimizing

127. The axis of Error
  * inefficiency
  * Frustration
    user notice
  * Failure
    user close the browser

## Part VI

128. The Samy Saga
  * How to hide JS in a URL in css
  * How to generate MySpace crumbs
  * How to submit a message to MySpace to update the friends myList
  * HOw to submit a message that contains a script that sends a message containing a script

  * Within 20 hours, his script was in one million accounts
  * He immediately stepped forward because he intended no harm
  * He was charged with a felony
  * Three years probation
  * 90 days community service
  * Banned from the internet

129.

## References

1. https://www.safaribooksonline.com/library/publisher/frontend-masters/
2. https://projecteuler.net/archives
3. https://www.amazon.com/gp/product/0984782850/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&tag=csdojo-20&camp=1789&creative=9325&linkCode=as2&creativeASIN=0984782850&linkId=023d89fe004b900faf117fb61819e1b5
4. https://leetcode.com/
